\renewcommand{\lstlistingname}{Пример} 

\etocsettocdepth.toc {section}

\chapterimage{chapter_head_0} 
\chapter{\DbgSecSt{\StPart}{Операторы}}
\label{sec:Operators}
\index{Операторы|(}
%--------------------------------------------------------
% *******begin section***************
\section{\DbgSecSt{\StPart}{Пустой оператор}}
\index{Операторы!Пустой оператор}

\begin{pHeader}
Синтаксис:      & \RightHandText{ ;}\\
\end{pHeader}

Пустой оператор ~-- оператор, который состоит только из точки с запятой. Он может появиться везде, где ожидается появление оператора. При выполнении пустого оператора ничего не происходит.\killoverfullbefore 

Операторы подобные do, for, if и while требуют наличия выполняемого оператора в теле оператора. В данном случае пустой оператор удовлетворяет синтаксическим требованиям, если действительно не нужно иметь выполняемое тело оператора. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Func}
\begin{tabular}{ l l }
for (i=0; i<10; array[i++]=0){ } ;  & \textcolor{exComm}{/* Выражение цикла array[i++]=0 в цикле for */} \\
 & \textcolor{exComm}{/* инициализирует первые 10 элементов array */} \\
 & \textcolor{exComm}{/* значением 0 */} \\
 & \textcolor{exComm}{/* Телом оператора является пустой оператор */} \\
\end{tabular}
\end{pExample}
% *******end section*****************

%--------------------------------------------------------
% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор-выражение}}
\index{Операторы!Оператор-выражение}

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pHeader}
Синтаксис:      & \RightHandText{выражение;}\\
\end{pHeader}

Любое выражение, которое заканчивается точкой с запятой, является оператором. 

Выполнение оператора выражение заключается в вычислении выражения. При выполнении оператора-выражения, выражение вычисляется в соответствии с правилами, приведенными в главе \myreftosecwithpage{Expressions}. \killoverfullbefore

Вызовы функций также считаются выражениями. В этом случае значением выражения будет возвращаемая функцией величина, если она имеется. Если функция возвращает значение, то оператор-выражение обычно содержит присвоение для записи возвращаемого значения при вызове функции. \killoverfullbefore

Возвращаемое функцией значение обычно используется в качестве операнда в другом выражении. Если значение будет использовано несколько раз, его можно присвоить другой переменной. Если значение не будет использовано в качестве операнда и не будет присвоено, то функция вызывается, а возвращаемое значение, если оно есть, не используется. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Func}
\begin{tabular}{ l l }
x=(y+3);  & \textcolor{exComm}{/* Оператор-выражение, которое присваивает x значение y+3 */} \\
x++; & \textcolor{exComm}{/* Оператор-выражение, которое увеличивает значение */} \\
 & \textcolor{exComm}{/* переменной х на 1 */} \\
a=cos(b*5); & \textcolor{exComm}{/* Оператор-выражение, включающее в себя операции */} \\
 & \textcolor{exComm}{/* присваивания и вызова функции */} \\
a(x,y);  & \textcolor{exComm}{/* Оператор-выражение, состоящее из вызова функции */} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Составной оператор}}
\index{Операторы!Составной оператор}

\begin{pHeader}
Синтаксис:      & \RightHandText{\{}\\
                & \RightHandText{[объявление]}\\  
                & \RightHandText{\vdots}\\
                & \RightHandText{оператор;}\\
                & \RightHandText{[оператор];}\\
                & \RightHandText{\vdots}\\
                & \RightHandText{\}}\\                
\end{pHeader}

Составной оператор представляет собой несколько операторов и объявлений, заключенных в фигурные скобки.  В конце составного оператора точка с запятой не ставится. \killoverfullbefore

Выполнение составного оператора заключается в последовательном выполнении составляющих его операторов. При выполнении составного оператора его операторы выполняются в том порядке, в котором они появляются, если не встретится оператор, который явно передает управление в другое место программы.\killoverfullbefore

В начале составного оператора могут содержаться объявления. Они служат для определения переменных, локальных для данного блока, либо для распространения на данный блок области действия глобальных объектов.\killoverfullbefore

Типично использование составного оператора в качестве тела другого оператора, например, оператора if.\killoverfullbefore \BL

\clearpage

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:CompositeOperator}
\begin{tabular}{ l l }
if (i>0) \{  & \textcolor{exComm}{/* Если i больше 0, то последовательно выполняются */} \\
\indent \indent array[i]=x; & \textcolor{exComm}{/* все операторы составного оператора */} \\
\indent \indent x++; & \textcolor{exComm}{} \\
\indent \indent \vdots & \textcolor{exComm}{} \\
\indent \indent double f, q; & \textcolor{exComm}{/* Переменные f, q будут уничтожены после */} \\
\indent \indent \vdots & \textcolor{exComm}{/* выполнения составного оператора */} \\
\indent \indent i{--}{--}; & \textcolor{exComm}{} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор if}}
\index{Операторы!Оператор if}

\begin{pHeader}
Синтаксис:      & \RightHandText{if (<выражение>)}\\
                & \RightHandText{\indent <оператор1> }\\
                & \RightHandText{[else}\\
                & \RightHandText{\indent <оператор2>]}\\
\end{pHeader}

Выполнение оператора if начинается с вычисления <выражения>.  Далее в зависимости от его значения:
\begin{itemize}
\item выполняется <оператор1>, если <выражение> истинно (отлично от 0);
\item выполняется <оператор2>, если <выражение> ложно (равно 0);
\item выполняется следующий за if оператор, если <выражение> ложно и отсутствует <оператор2>. 
\end{itemize}

Оператор if может быть вложен в <оператор1> или <оператор2> другого оператора if. При вложении операторов if рекомендуется для ясности группирования операторов использовать фигурные скобки, ограничивающие <оператор1> и <оператор2>. \killoverfullbefore

Если же фигурные скобки отсутствуют, то компилятор ассоциирует каждое ключевое слово else с ближайшим оператором if, у которого отсутствует конструкция else. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:ifOperator}
\begin{tabular}{ l l }
if (i>0) & \textcolor{exComm}{/* Если i больше 0, то выполняется оператор y=x/i */} \\
\indent \indent y=x/i; & \textcolor{exComm}{} \\
else \{ & \textcolor{exComm}{/* Если i меньше или равно нулю, то значение i присваивается */} \\
\indent \indent x=i; & \textcolor{exComm}{/* x и значение функции f(x) присваивается y */}  \\
\indent \indent y=f(x); & \textcolor{exComm}{} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор for}}
\index{Операторы!Оператор for}

\begin{pHeader}
Синтаксис:      & \RightHandText{for([<начальное-выражение>];}\\
                & \RightHandText{[<условное-выражение>];}\\
                & \RightHandText{[<выражение-цикла>])}\\
                & \RightHandText{тело-оператора}\\
\end{pHeader}

Оператор for ~-- наиболее общий способ организации цикла. 

<Начальное-выражение> обычно используется для установления начального значения переменных, управляющих циклом. <Условное-выражение> ~-- выражение, определяющее условие, при котором тело цикла будет выполняться. <Выражение-цикла> определяет изменение переменных, управляющих циклом после каждого выполнения тела цикла. \killoverfullbefore

Тело оператора for выполняется до тех пор, пока <условное-выражение> не станет ложным. Если оно изначально ложно, то тело цикла не будет выполнено ни разу. \killoverfullbefore

Внутри оператора for можно использовать локальные переменные, которые должны быть объявлены с определением соответствующих типов. 

Выполнение оператора for начинается с вычисления <начального-выражения> при его наличии.  Далее рассчитывается <условное-выражение> и в зависимости от его значения:
\begin{itemize}
\item выполняется тело оператора, если <условное-выражение> истинно (не равно 0);
\item выполнение оператора for заканчивается и управление передается следующему за ним оператору, если <условное-выражение> ложно (равно 0). \killoverfullbefore \BL
\end{itemize}

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:returnOperator}
\begin{tabular}{ l l }
int i, b; & \textcolor{exComm}{/* Объявления переменных i и b */} \\
for (i=1; i<10; i++)  & \textcolor{exComm}{/* Вычисление квадратов чисел от 1 до 9 */} \\
\indent b=i*i; & \textcolor{exComm}{ } \\
\end{tabular}
\end{pExample}

Если условное выражение отсутствует, то его значение принимается за истину и процесс выполнения продолжается, как описано выше. В этом случае оператор цикла for представляет бесконечный цикл, который может завершиться только при выполнении в его теле операторов break или return. Тело оператора for может быть пустым, как показано в примере ниже. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:forOperator}
\begin{tabular}{ l l }
for ( ; ; ) \{ & \textcolor{exComm}{ } \\
\indent  \vdots & \textcolor{exComm}{ } \\
\indent if (\dots) break; & \textcolor{exComm}{ } \\
\indent  \vdots & \textcolor{exComm}{ } \\
\} & \textcolor{exComm}{ } \\
\end{tabular}
\end{pExample}

% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор while}}
\index{Операторы!Оператор while}

\begin{pHeader}
Синтаксис:      & \RightHandText{while (<выражение>)}\\
                & \RightHandText{тело оператора}\\
\end{pHeader}

Оператор цикла while называется циклом с предусловием. Тело оператора цикла while выполняется до тех пор, пока значение выражение не станет ложным (равным 0). В качестве выражения допускается использовать любое выражение языка, а в качестве оператора ~--  любой оператор, в том числе пустой или составной. \killoverfullbefore

Выполнение оператора while начинается с вычисления выражения. Далее в зависимости от его значения:
\begin{itemize}
\item выполняется тело оператора, если выражение истинно (отлично от 0), перед каждым следующим выполнением тела цикла выражение вычисляется заново;
\item выполнение оператора while заканчивается и выполняется следующий по порядку оператор, если <выражение> ложно (равно 0). 
\end{itemize}

Так же как и при выполнении оператора for, в операторе while вначале происходит проверка условия. Если выражение изначально ложно, то тело оператора while вообще не выполняется и управление сразу передается на следующий за телом цикла оператор программы. Поэтому оператор while удобно использовать в ситуациях, когда тело оператора не всегда нужно выполнять. \killoverfullbefore

Внутри оператора while можно использовать локальные переменные, которые должны быть объявлены с определением соответствующих типов. \killoverfullbefore

Оператор цикла while может также завершиться при выполнении операторов break или return внутри своего тела. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:whileOperator}
\begin{tabular}{ l l }
while (i > 0) \{ & \textcolor{exComm}{/* Если i больше 0, выполняется тело цикла и значение i*/} \\
\indent  \vdots & \textcolor{exComm}{/* уменьшается. Когда оно станет меньше 1, */} \\
\indent i{--}{--}; & \textcolor{exComm}{/* выполнение оператора while заканчивается */} \\
\} & \textcolor{exComm}{ } \\
\end{tabular}
\end{pExample}

% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор do while}}
\index{Операторы!Оператор do while}

\begin{pHeader}
Синтаксис:  & \RightHandText{do }\\ 
            & \RightHandText{тело-оператора}\\   
            & \RightHandText{while (<выражение>)}\\
\end{pHeader}

Оператор цикла do while называется оператором цикла с постусловием и используется в тех случаях, когда необходимо выполнить тело цикла хотя бы один раз. \killoverfullbefore

Тело оператора do выполняется один или несколько раз до тех пор, пока значение <выражения> не станет ложным (равным 0) следующим образом:
\begin{itemize}
\item выполняется тело оператора;
\item вычисляется <выражение>; 
\item если <выражение> истинно (отлично от 0), тело оператора выполняется снова;
\item если <выражение> ложно (равно 0), выполнение оператора заканчивается и выполняется следующий по порядку оператор. \killoverfullbefore \BL
\end{itemize}

Оператор может завершиться при выполнении в своем теле операторов break или return. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:whileOperator}
\begin{tabular}{ l l }
do \{ & \textcolor{exComm}{/* Вначале выполняется составной оператор */} \\
\indent  у = f(x); & \textcolor{exComm}{/* Затем вычисляется выражение х > 0 */} \\
\indent x{--}{--}; & \textcolor{exComm}{/* Если оно истинно, то составной оператор выполняется снова */} \\
\} while(x > 0); & \textcolor{exComm}{ } \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор switch}}
\index{Операторы!Оператор switch}

\begin{pHeader}
Синтаксис:      & \RightHandText{switch (<выражение>) \{}\\
                & \RightHandText{\indent [объявление]}\\
                & \RightHandText{\indent \vdots}\\
                & \RightHandText{\indent [case константное-выражение:]}\\
                & \RightHandText{\indent \indent [список операторов]}\\
                & \RightHandText{\indent \indent \vdots}\\
                & \RightHandText{\indent [case константное-выражение:]}\\
                & \RightHandText{\indent \indent [список операторов]}\\
                & \RightHandText{\indent \indent \vdots}\\
                & \RightHandText{\indent [default:}\\
                & \RightHandText{\indent \indent [список операторов]]}\\
                & \RightHandText{\}}\\
\end{pHeader}

Оператор switch предназначен для организации выбора из множества различных вариантов. 

Выражение, следующее за ключевым словом switch в круглых скобках, может быть любым выражением, значение которого должно быть целым. Можно использовать явное приведение к целому типу.\killoverfullbefore

Значение <выражения> является ключевым для выбора из нескольких вариантов: управление будет передано тому оператору, значение [case константное-выражение:] которого совпадает с выражением switch. Тело оператора switch состоит из нескольких операторов, помеченных ключевым словом case с последующим константным выражением. Использование целого константного выражения является существенным недостатком, присущим рассмотренному оператору. Обычно в качестве константного выражения используются целые или символьные константы. \killoverfullbefore

Все константные выражения в операторе switch должны быть уникальны. Кроме операторов, помеченных ключевым словом case, может быть, но обязательно один, фрагмент помеченный ключевым словом default. \killoverfullbefore

Список операторов может быть пустым, либо содержать один или более операторов. В операторе switch не требуется заключать последовательность операторов в фигурные скобки. На один список операторов может указывать несколько меток case. \killoverfullbefore

В операторе switch можно использовать свои локальные переменные, объявления которых находятся перед первым ключевым словом case, однако в объявлениях не должна использоваться инициализация. \killoverfullbefore

Использование оператора break позволяет в необходимый момент прервать последовательность выполняемых операторов в теле оператора switch, путем передачи управления оператору, следующему за switch.  \killoverfullbefore

В теле оператора switch можно использовать вложенные операторы switch, при этом в ключевых словах case можно использовать одинаковые константные выражения. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:switchOperator}
\begin{tabular}{ l l }
 switch (i) \{ & \textcolor{exComm}{} \\
\indent case 0: & \textcolor{exComm}{} \\
\indent case 1: n++;  & \textcolor{exComm}{/* Инкрементирование значения переменной n */} \\
\indent \indent break; & \textcolor{exComm}{/* Принудительный выход из тела оператора */} \\
\indent case 2: n{--}{--};  & \textcolor{exComm}{/* Декрементирование значения переменной n */} \\
\indent \indent break; & \textcolor{exComm}{/* Принудительный выход из тела оператора  */} \\
\indent case -1: n=0;  & \textcolor{exComm}{/* Обнуление значения переменной n */} \\
\indent \indent break; & \textcolor{exComm}{/* Принудительный выход из тела оператора  */} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}

% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор break}}
\index{Операторы!Оператор break}

\begin{pHeader}
Синтаксис:      & \RightHandText{break;}\\
\end{pHeader}

Оператор break прерывает выполнение операторов do, for, switch или while, в которых он появляется. Он может содержаться только в теле этих операторов. Управление передается тому оператору, который непосредственно следует за прерванным оператором. \killoverfullbefore

Если оператор break записан внутри вложенных операторов do, for, while, switch, то он завершает только непосредственно охватывающий его оператор do, for, while, switch. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:breakOperator}
\begin{tabular}{ l l }
 while (i{--}{--} > 0) \{ & \textcolor{exComm}{/* Тело оператора while выполняется, если i больше 0 */} \\
\indent x=f(i);  & \textcolor{exComm}{/* Значение функции f(i) присваивается x */} \\
\indent if (x==1) & \textcolor{exComm}{/* Если x равно 1, выполняется оператор break,    */} \\
\indent \indent break; & \textcolor{exComm}{/* который прерывает выполнение цикла, */} \\
\indent y+=x*x; & \textcolor{exComm}{/* остальные операторы игнорируются */} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор continue}}
\index{Операторы!Оператор continue}

\begin{pHeader}
Синтаксис:      & \RightHandText{continue;}\\
\end{pHeader}

Оператор продолжения continue передает управление на следующую итерацию в операторах цикла do, for, while. Он может появиться только в теле этих операторов. Остающиеся в теле цикла операторы при этом не выполняются. \killoverfullbefore

В операторах цикла do и while следующая итерация начинается с вычисления условного выражения. Для оператора for следующая итерация начинается с вычисления выражения приращения, а затем происходит вычисление условного выражения. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:continueOperator}
\begin{tabular}{ l l }
 while (i{--}{--} > 0) \{ & \textcolor{exComm}{/* Тело оператора while выполняется, если i больше 0 */} \\
\indent x=f(i);  & \textcolor{exComm}{/* Значение функции f(i) присваивается x */} \\
\indent if (x==1) & \textcolor{exComm}{/* Если x равно 1, выполняется оператор continue,    */} \\
\indent \indent continue; & \textcolor{exComm}{/* осуществляется переход в начало цикла, */} \\
\indent y+=x*x; & \textcolor{exComm}{/* остальные операторы игнорируются */} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Оператор return}}
\index{Операторы!Оператор return}

\begin{pHeader}
Синтаксис:      & \RightHandText{return [выражение];}\\
\end{pHeader}

Оператор return завершает выполнение функции, в которой он задан, и возвращает управление в вызывающую функцию, в точку, непосредственно следующую за вызовом. \killoverfullbefore

Значение выражения, если оно задано, возвращается в вызывающую функцию в качестве значения вызываемой функции. Если выражение опущено, то возвращаемое значение не определено. Выражение может быть заключено в круглые скобки, хотя их наличие не обязательно.\killoverfullbefore

Если в какой-либо функции отсутствует оператор return, то передача управления в вызывающую функцию происходит после выполнения последнего оператора вызываемой функции. При этом возвращаемое значение не определено. Если функция не должна иметь возвращаемого значения, то ее нужно объявлять с типом void. \killoverfullbefore

Использование оператора return необходимо либо для немедленного выхода из функции, либо для передачи возвращаемого значения. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:returnOperator}
\begin{tabular}{ l l }
int add (int a, int b)  & \textcolor{exComm}{/* Функция add имеет два формальных параметра */} \\
\{  & \textcolor{exComm}{/* a и b типа int и возвращает значение типа int */} \\
\indent return (a+b); & \textcolor{exComm}{/* Возвращаемое оператором return значение равно сумме*/} \\
\} & \textcolor{exComm}{/* фактических параметров */} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------
\index{Операторы|)}

\clearpage