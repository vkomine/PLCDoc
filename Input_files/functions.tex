\renewcommand{\lstlistingname}{Пример} 

\etocsettocdepth.toc {section}

\chapterimage{chapter_head_0} 
\chapter{\DbgSecSt{\StPart}{Функции}}
\label{sec:Functions}
\index{Функции|(}

Функция ~-- совокупность объявлений и операторов, предназначенная для выполнения некоторой отдельной задачи. Количество функций в программе не ограничивается. \killoverfullbefore

С использованием функций связаны три понятия - определение функции (описание действий, выполняемых функцией), объявление  или прототип  функции (задание формы обращения к функции) и вызов функции. \killoverfullbefore  
%--------------------------------------------------------
% *******begin section***************
\section{\DbgSecSt{\StPart}{Определение функций}}
\index{Функции!Определение функций}

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pHeader}
Синтаксис:      & \RightHandText{[спецификатор-класса-памяти] [спецификатор-типа] <описатель> ([список-формальных-параметров])}\\
                & \RightHandText{\{    }\\     
                & \RightHandText{ тело-функции        }\\                 
                & \RightHandText{  \}             }\\                 
\end{pHeader}

Определение функции специфицирует имя функции, тип и число её формальных параметров, а также тело функции, содержащее объявления и операторы. Эти объявления и операторы называются <<телом функции>>. Кроме того, в определении функции может устанавливаться тип возвращаемого значения и класс памяти. \killoverfullbefore

%Определение функции специфицирует имя функции, атрибуты ее формальных параметров, и тело функции, содержащее объявления и операторы. В определении функции также может задаваться тип возвращаемого значения.

Необязательный спецификатор-класса-памяти задает класс памяти функции, который может быть static или extern. Функция с классом хранения static доступна только в том исходном файле, где она появляется. Все другие функции, явно или неявно определенные с классом хранения extern, доступны из всех исходных файлов, составляющих программу. \killoverfullbefore

Спецификатор-типа функции устанавливает размер и тип значения, возвращаемого функцией.
Функция возвращает значение, если её выполнение заканчивается оператором return, содержащим некоторое выражение. Указанное выражение вычисляется, преобразуется, если необходимо, к типу возвращаемого значения и возвращается в точку вызова функции в качестве результата. Если оператор return не содержит выражения или выполнение функции завершается после выполнения последнего её оператора (без выполнения оператора return), то возвращаемое значение не определено. Для функций, не использующих возвращаемое значение, должен быть использован тип void, указывающий на отсутствие возвращаемого значения.\killoverfullbefore

Список-формальных-параметров представляет собой последовательность объявлений формальных параметров, разделенная запятыми. Формальные параметры ~-- переменные, используемые внутри тела функции и получающие значение при вызове функции, в соответствии с порядком следования их имен в списке параметров, путем копирования в них значений соответствующих фактических параметров. \killoverfullbefore

Если функция не использует параметров, то наличие круглых скобок обязательно, а вместо списка параметров рекомендуется указать слово void. \killoverfullbefore

Порядок и типы формальных параметров должны быть одинаковыми в определении функции и во всех ее объявлениях. Типы фактических параметров при вызове функции должны быть совместимы с типами соответствующих формальных параметров. Тип формального параметра может быть любым основным типом, структурой, объединением, перечислением, указателем или массивом. \killoverfullbefore

Тело функции - это составной оператор, содержащий операторы, определяющие действие функции. Тело функции кроме того может содержать объявления переменных, которые используются этими операторами.  \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Func}
\begin{tabular}{ l l }
double add(double x, double y) & \textcolor{exComm}{/* Определение функции add */} \\
\{ & \textcolor{exComm}{} \\
\indent return (x + y); & \textcolor{exComm}{/* Тело функции */} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Объявление или прототип функции}}
\index{Функции!Вызовы функций}

\begin{pHeader}
Синтаксис:      & \RightHandText{[спецификатор-класса-памяти] [спецификатор-типа] <описатель> ([список-формальных-параметров]);}\\                   
\end{pHeader}

Объявление или прототип функции определяет её имя, тип возвращаемого значения и класс памяти. Кроме того, в нем могут быть установлены типы и идентификаторы для некоторых или всех аргументов функции. \killoverfullbefore

Прототип ~-- явное объявление функции, которое предшествует определению функции. \killoverfullbefore

Прототип имеет тот же формат, что и определение функции, за тем исключением, что у него нет тела и он заканчивается точкой с запятой сразу же после закрывающей  скобки.\killoverfullbefore

Тип возвращаемого значения при объявлении функции должен соответствовать типу возвращаемого значения в определении функции. \killoverfullbefore

Основное назначение предварительного объявления состоит в задании типов и числа аргументов, ожидаемых в вызове функции. Список типов аргументов позволяет осуществить контроль типов аргументов при вызове функции. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Call}
\begin{tabular}{ l l }
double add(double, double);  & \textcolor{exComm}{/* Объявление функции  add с параметрами*/}  \\ 
\vdots & \textcolor{exComm}{/* типа double и возвращаемым значением */}  \\
\vdots & \textcolor{exComm}{/* типа double */} \\
double add(double x, double y) & \textcolor{exComm}{/* Определение функции add */} \\
\{ & \textcolor{exComm}{} \\
\indent return (x + y); & \textcolor{exComm}{/* Тело функции */} \\
\} & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Вызовы функций}}
\index{Функции!Вызовы функций}

\begin{pHeader}
Синтаксис:      & \RightHandText{<выражение>([<список-выражений>]) }\\                   
\end{pHeader}
%адресное-выражение 

Вызов функции передает управление и фактические аргументы заданной функции.

%При вызове записывается имя функции (идентификатор), а за ним следует список выражений в скобках. Функция вызывается аналогично своему объявлению. 

Значение <выражения> интерпретируется как адрес функции. Функция может быть вызвана не только по имени (идентификатору), но и через любое выражение, имеющее тип указателя на функцию.

%<Выражение> должно ссылаться на функцию. Это означает, что функция может быть вызвана через любое выражение указателя на функцию. 

Список выражений, в котором выражения следуют через запятую, представляет собой перечень фактических аргументов, передаваемых функции. Список выражений может быть пустым.

При выполнении вызова функции происходит копирование значений фактических аргументов в формальные параметры.  Перед этим над каждым фактическим аргументом выполняются необходимые преобразования. Первый фактический аргумент соответствует первому формальному параметру, второй — второму и т. д. Фактический аргумент может быть любым значением базового типа, структурой, объединением или указателем. 
 
Возможность доступа из функции не к копиям значений, а к самим переменным обеспечивают указатели. Указатель на переменную содержит ее адрес, и функция может использовать этот адрес для изменения значения переменной. \killoverfullbefore \BL
 
  \begin{pExample}
  \IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Call}
  \begin{tabular}{ l l }
  double *comp(double value1, double value2);  & \textcolor{exComm}{/* Объявление функции  comp с */}  \\
  \vdots & \textcolor{exComm}{/* параметрами типа double и */}  \\
  \vdots & \textcolor{exComm}{/* возвращаемым значением, */} \\
   \vdots & \textcolor{exComm}{/* указателем на double */} \\
\end{tabular}

  \begin{tabular}{ l l }
  double a, b, *rp; & \textcolor{exComm}{} \\
   \vdots & \textcolor{exComm}{} \\
  rp=comp(a, b); & \textcolor{exComm}{/* Вызов функции */} \\
  \end{tabular}
  \end{pExample}
 
 \begin{pExample}
 \IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Call}
 \begin{tabular}{ l l }
 int (*fun)(int x, int *y);  & \textcolor{exComm}{/* Объявление переменной fun как указателя на функцию  */}  \\
  \vdots & \textcolor{exComm}{/* с параметрами типа int и указателем на int и */}  \\
  \vdots & \textcolor{exComm}{/* возвращаемым значением типа int */} \\
 (*fun)(i,\&j);  & \textcolor{exComm}{/* Вызов функции после инициализации указателя fun */} \\
 \end{tabular}
 \end{pExample}
% *******end section*****************
%--------------------------------------------------------

\index{Функции|)}

\clearpage