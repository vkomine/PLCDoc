\renewcommand{\lstlistingname}{Пример} 

\etocsettocdepth.toc {subsection}

\chapterimage{chapter_head_0} 
\chapter{\DbgSecSt{\StPart}{Директивы препроцессора}}
\label{sec:Preprocessor}
\index{Директивы препроцессора|(}

Директивы препроцессора ~-- инструкции препроцессору, то есть текстовому процессору, который обрабатывает текст исходного файла. 

Расположенные в исходном файле директивы заставляют препроцессор выполнять различные действия. Например, заменить лексемы в тексте, вставить содержимое других файлов в исходный файл или подавить компиляцию части файла, удаляя сегменты текста. 

Препроцессор распознает приведённые ниже директивы.

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{1.0cm}   %% increase table column spacing
\begin{center}
\begin{tabular}{ l l }
\#define & \#ifdef \\
\#elif & \#ifndef  \\
\#else & \#include \\
\#endif & \#undef \\
\#if &  \\
\end{tabular}
\end{center}
%\#line%
Знак решётки (\#) должен быть первым неразделительным символом на строке, содержащей директиву, между символом номера и первой буквой директивы могут появляться разделительные символы. Некоторые директивы содержат аргументы или значения. Любой текст, который следует за директивой (кроме аргумента или значения, который является частью директивы) должен быть заключен в скобки комментария \\ (/*  */). \killoverfullbefore

Директивы препроцессора могут появляться в произвольном месте исходного файла, но они будут воздействовать только на оставшуюся часть исходного файла, в котором они появились. \killoverfullbefore

 %--------------------------------------------------------
% *******begin section***************
\section{\DbgSecSt{\StPart}{Именованные константы и макроопределения}}
\index{Директивы препроцессора!Именованные константы и макроопределения}

Директива \#define обычно используется для замены часто используемых в программе констант, ключевых слов, операторов и выражений содержательными идентификаторами. \killoverfullbefore

Идентификаторы, которые заменяют числовые или текстовые константы либо произвольную последовательность символов, называются именованными константами. Идентификаторы, которые представляют некоторую последовательность действий, заданную операторами или выражениями языка, называются макроопределениями. Макроопределения могут иметь аргументы. Обращение к макроопределению в программе называется макровызовом.\killoverfullbefore

Директива \#undef отменяет текущее определение именованной константы. Только когда определение отменено, именованной константе может быть сопоставлено другое значение. Однако многократное повторение определения с одним и тем же значением не считается ошибкой.\killoverfullbefore

Макроопределение напоминает по синтаксису определение функции. Однако замена вызова функции макровызовом может повысить скорость выполнения программы, поскольку для макроопределения не требуется генерировать вызывающую последовательность.\killoverfullbefore
% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{\#define}}
\index{Директивы препроцессора!Именованные константы и макроопределения!\#define}
\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pHeader}
Синтаксис:      & \RightHandText{\#define <идентификатор> <текст>}\\
                & \RightHandText{\#define <идентификатор> <список параметров> <текст>}\\    
\end{pHeader}

Директива \#define заменяет все вхождения <идентификатора> в исходном файле на <текст>, следующий в директиве за <идентификатором>. \killoverfullbefore

<Идентификатор> заменяется лишь в том случае, если он представляет собой отдельную лексему. Если за <идентификатором> следует <список параметров>, то директива определяет макроопределение с аргументами.\killoverfullbefore

<Текст> представляет собой набор лексем, таких как ключевые слова, константы, идентификаторы или выражения. Один или более пробельных символов должны отделять <текст> от <идентификатора> (или от заключенных в скобки параметров). Если текст не умещается на строке, то он может быть продолжен на следующей строке.\killoverfullbefore

<Список параметров>, если он задан, содержит один или более идентификаторов, разделенных запятыми. Идентификаторы в списке должны отличаться друг от друга. Их область действия ограничена макроопределением, в котором они заданы. Список должен быть заключен в круглые скобки. Имена формальных параметров в <тексте> отмечают позиции, в которые должны быть подставлены фактические аргументы макровызова. Каждое имя формального параметра может появиться в <тексте> произвольное число раз.\killoverfullbefore

В вызове макроопределения следом за <идентификатором> записывается в круглых скобках список фактических аргументов, соответствующих формальным параметрам из <списка параметров>. <Текст> модифицируется путем замены каждого формального параметра на соответствующий фактический аргумент. Списки фактических аргументов и формальных параметров должны содержать одно и то же число элементов.\killoverfullbefore

Конструкция <текст> в директиве \#define может содержать имена других макроопределений или констант. Их расширение производится лишь при расширении <идентификатора> этого <текста>, а не при его определении директивой \#define. Это надо учитывать, в частности, при взаимодействии вложенных именованных констант и макроопределений с директивой \#undef: к моменту расширения содержащего их текста они могут уже оказаться отменены директивой \#undef.\killoverfullbefore

После того как выполнена макроподстановка, полученная строка вновь просматривается для поиска других имен констант и макроопределений. При повторном просмотре не принимается к рассмотрению имя ранее произведенной макроподстановки.\killoverfullbefore \BL

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Define}
\begin{tabular}{ l l }
\#define WIDTH 80 & \textcolor{exComm}{/* Идентификатор WIDTH определён */}  \\
 & \textcolor{exComm}{/* как целая константа со значением 80 */}  \\
\#define LENGTH (WIDTH + 10) & \textcolor{exComm}{/* Идентификатор LENGTH определён */} \\
 & \textcolor{exComm}{/* как (WIDTH + 10)  */} \\
\#define FILEMESSAGE "Ошибка записи" & \textcolor{exComm}{/* Идентификатор FILEMESSAGE */} \\
\#define MAX(x, y)((x)>(у)) ? (x) : (у) & \textcolor{exComm}{/* Макроопределение МАХ */} \\
\#define MULT(a, b) ((a)*(b)) & \textcolor{exComm}{/* Макроопределение MULT */} \\
\vdots & \textcolor{exComm}{ } \\
z =  MAX(a, b); & \textcolor{exComm}{/* Вызов макроопределения МАХ */} \\
\vdots & \textcolor{exComm}{/* возвращает наибольшее значение */} \\
\end{tabular}
\end{pExample}

%\index{Директивы препроцессора! Склейка лексем и преобразование аргументов макроопределений}
%\mylbl{Склейка лексем и преобразование аргументов макроопределений}{GluingLexemes}\BL

\subsection{\DbgSecSt{\StPart}{Склейка лексем и преобразование аргументов макроопределений}}
\index{Директивы препроцессора!Именованные константы и макроопределения!Склейка лексем и преобразование аргументов макроопределений}

В директиве \#define две лексемы могут быть <<склеены>> вместе. Для этого их нужно разделить знаками \#\# (слева и справа от \#\# допустимы пробельные символы). Препроцессор объединяет такие лексемы в одну. \killoverfullbefore \BL
%Например, макроопределение \#define VAR (i,j) i\#\#j при макровызове VAR(х,6) образует идентификатор х6.\killoverfullbefore

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Glue}
\begin{tabular}{ l l }
\#define VAR (i,j) i\#\#j & \textcolor{exComm}{/* Макроопределение VAR */}  \\
\vdots & \textcolor{exComm}{ } \\
VAR(х,6); & \textcolor{exComm}{/* Вызов макроопределения VAR образует идентификатор х6 */} \\
\end{tabular}
\end{pExample}

%Символ \#, помещаемый перед аргументом макроопределения, указывает на необходимость преобразования его в символьную строку. При вызове макроопределения конструкция \#<формальный параметр> заменяется на фактический аргумент.\killoverfullbefore

% *******end subsection*****************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{\#undef}}
\index{Директивы препроцессора!Именованные константы и макроопределения!\#undef}

\begin{pHeader}
    Синтаксис:      & \RightHandText{\#undef <идентификатор>}\\
\end{pHeader}

Директива \#undef отменяет действие текущего определения \#define для <идентификатора>. Чтобы отменить макроопределение посредством директивы \#undef, достаточно задать его <идентификатор>. Задание списка параметров не требуется.\killoverfullbefore

Директива \#undef обычно используется в паре с директивой \#define, чтобы создать область исходной программы, в которой некоторый идентификатор определен.\killoverfullbefore
% *******end subsection*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Включение файлов}}
\index{Директивы препроцессора!Включение файлов}

\begin{pHeader}
    Синтаксис:      & \RightHandText{\#include "имя пути"}\\
                    & \RightHandText{\#include <имя пути>}\\
\end{pHeader}

Директива \#include включает содержимое исходного файла, имя пути которого задано, в текущий исходный файл.\killoverfullbefore 

Например, общие для нескольких исходных файлов определения именованных констант и макроопределения могут быть собраны в одном включаемом файле и включены директивой \#include во все исходные файлы. Включаемые файлы используются также для хранения объявлений внешних переменных и абстрактных типов данных, разделяемых несколькими исходными файлами.\killoverfullbefore

Препроцессор обрабатывает включаемый файл таким же образом, как если бы этот файл целиком входил в состав исходного файла в точке, где записана директива \#include. Включаемый текст также может содержать директивы препроцессора. Препроцессор выполняет обработку включаемого файла, а затем возвращается к обработке первоначального исходного файла.\killoverfullbefore

Имя пути представляет собой имя файла, которому может предшествовать имя устройства и спецификация директории. Поиск ведётся до тех пор, пока не будет обнаружен файл с заданным именем.\killoverfullbefore

Если имя пути задано однозначно (полностью) и заключено в двойные кавычки, то препроцессор ищет файл только в директории, специфицированной заданным именем пути, а стандартные директории игнорирует.\killoverfullbefore

Если заданная в кавычках спецификация не образует полное имя пути, то поиск включаемого файла начинается в текущей рабочей директории, то есть в той директории, которая содержит исходный файл, в котором записана директива \#include.\killoverfullbefore

Если же имя пути заключено в угловые скобки, то поиск не будет осуществляться в текущей рабочей директории, а сразу начнется в стандартных директориях.\killoverfullbefore

Имеется возможность задавать имя пути в директиве \#include с помощью именованной константы. \killoverfullbefore

Директива \#include может быть вложенной. Это значит, что она может встретиться в файле, включенном другой директивой \#include. \killoverfullbefore \BL

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:Include}
\begin{tabular}{ l l }
\#include "myinclude.h" & \textcolor{exComm}{/* файл myinclude.h в текущей директории */
}  \\
\#define myinclude "include/mystuff.h" & \textcolor{exComm}{/* Определение именованной константы */} \\
\#include myinclude & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}

% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Условная компиляция}}
\index{Директивы препроцессора!Условная компиляция}

Директивы, управляющие условной компиляцией, позволяют подавить компиляцию части исходного файла, проверяя постоянное выражение или идентификатор. Результат проверки определяет, какие блоки текста будут переданы в компилятор и какие блоки текста будут удалены из исходного файла при предпроцессорной обработке. \killoverfullbefore

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{\#if, \#elif, \#else, \#endif}}
\index{Директивы препроцессора!Именованные константы и макроопределения!\#if, \#elif, \#else, \#endif}

\begin{pHeader}
Синтаксис: & \RightHandText{\#if <ограниченное-константное-выражение> <текст>}\\
           & \RightHandText{\#elif <ограниченное-константное-выражение> <текст>}\\
           & \RightHandText{\#else <текст>}\\
           & \RightHandText{\#endif}\\           
\end{pHeader}

Директива \#if вместе с директивами \#elif, \#else и \#endif управляют компиляцией части исходного файла. Каждая директива \#if в исходном файле должна иметь соответствующую закрывающую директиву \#endif. Между директивами \#if и \#endif может появиться любое число директив \#elif, но допускается наличие только одной директивы \#else. Если имеется директива \#else, то она должна быть последней директивой перед \#endif. \killoverfullbefore

Препроцессор выбирает одно из заданных появлений блока текста для дальнейшей обработки. Этот блок может быть любой последовательностью текста. Если блок текста содержит директивы препроцессора, то препроцессор выполнит эти директивы. Все блоки текста, не выбранные препроцессором, удаляются из обрабатываемого файла. \killoverfullbefore

Препроцессор выбирает отдельный блок текста вычисляя выражение граничной константы, которое следует за каждой директивой \#if или \#elif, пока результатом выражения граничной константы не будет <<истина>>. Выбирается весь текст (включая начинающиеся с \# другие директивы препроцессора) до соответствующего \#elif, \#else или \#endif. \killoverfullbefore

Если значением всех выражений граничных констант будет <<ложь>> или отсутствует директива \#elif, то препроцессор выберет блок текста после предложения \#else. Если предложения \#else нет, то блок вообще не выбирается. \killoverfullbefore

Директивы \#if могут быть вложенными. При этом каждая из директив \#else, \#elif, \#endif ассоциируется с ближайшей предшествующей директивой \#if.\killoverfullbefore

Выражения граничной константы не могут содержать приведения типа или перечислимых констант. Однако, они могут содержать оператор defined в специальном постоянном выражении, имеющем следующий синтаксис: defined <идентификатор>. \killoverfullbefore

Данное постоянное выражение будет иметь значение <<истина>>, если заданный идентификатор определен, в противном случае ~-- <<ложь>>. Идентификатор, определенный как пустой текст, считается определенным. Операция defined может использоваться в сложном выражении в директиве \#if неоднократно: \#if defined(message1) || defined(message2).\killoverfullbefore \BL

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:ConditionalCompilation1}
\begin{tabular}{ l l }
\#if DLEVEL == 0 & \textcolor{exComm}{}  \\
\indent \indent \#define STACK 0 & \textcolor{exComm}{/* Если идентификатор DLEVEL равен 0 */} \\
\#elif DLEVEL == 1 & \textcolor{exComm}{} \\
\indent \indent \#define STACK 100 & \textcolor{exComm}{/* Если идентификатор DLEVEL равен 1 */} \\
\#elif DLEVEL > 5 & \textcolor{exComm}{} \\
\indent \indent func(); & \textcolor{exComm}{/* Если идентификатор DLEVEL > 5 */} \\
\#else & \textcolor{exComm}{} \\
\indent \indent \#define STACK 200 & \textcolor{exComm}{ }\\
\#endif & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:ConditionalCompilation2}
\begin{tabular}{ l l }
\#if defined(DATA1) & \textcolor{exComm}{}  \\
\indent \indent func1(); & \textcolor{exComm}{/* Если определен идентификатор DATA1 */}\\
\#elif  defined(DATA2) & \textcolor{exComm}{} \\
\indent \indent func2(); & \textcolor{exComm}{/* Если определен идентификатор DATA2 */}\\
\#else  & \textcolor{exComm}{} \\
\indent \indent func3(); & \textcolor{exComm}{/* Если не определен DATA1 и DATA2 */}\\
\#endif & \textcolor{exComm}{} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{\#ifdef, \#ifndef}}
\index{Директивы препроцессора!Именованные константы и макроопределения!\#ifdef, \#ifndef}

\begin{pHeader}
Синтаксис: & \RightHandText{\#ifdef <идентификатор>}\\
           & \RightHandText{\#ifndef <идентификатор>}\\         
\end{pHeader}

Директивы \#ifdef и \#ifndef выполняют те же функции, что и директива \#if с defined<идентификатор>. \killoverfullbefore

Директивы \#ifdef и \#ifndef можно использовать везде, где допустимо использование \#if. Предпочтительно использовать постоянное выражение defined<идентификатор> c с директивой \#if. \killoverfullbefore

Когда препроцессор обнаруживает директиву \#ifdef, он проверяет, определен ли идентификатор. Если определен, то значение условия <<истина>>, в противном случае <<ложь>>. \killoverfullbefore

Директива \#ifndef проверяет условие, противоположное условию \#ifdef. Если идентификатор не определен (или его определение удалено с помощью \#undef), то значение условия <<истина>>, в противном случае <<ложь>>. \killoverfullbefore

% *******end subsection*****************
% *******end section*****************
%--------------------------------------------------------

\index{Директивы препроцессора|)}

\clearpage