\renewcommand{\lstlistingname}{Пример}

\etocsettocdepth.toc {section}

\chapterimage{chapter_head_0} 
\chapter{\DbgSecSt{\StPart}{Выражения и присваивания}}
\label{sec:Expressions}
\index{Выражения и присваивания|(}

Выражение — это комбинация операндов и операций, задающая порядок вычисления некоторого значения. Операции определяют действия, выполняемые над операндами. Операнд в простейшем случае является константой или переменной. В общем случае каждый операнд выражения также представляет собой выражение, имеющее некоторое значение. \killoverfullbefore

При вычислении выражений тип каждого операнда может быть преобразован к другому типу. Преобразования типов могут быть неявными, при выполнении операций и вызовов функций, или явными, при выполнении операций приведения типов. \killoverfullbefore

Результат вычисления выражения зависит от приоритета операций, а также от возможных побочных эффектов. Приоритет операций определяет группирование операндов в выражении и последовательность выполнения операций. Побочным эффектом называется изменение значения какого-либо операнда, вызванное вычислением другого операнда. Для некоторых операций возникновение побочного эффекта зависит от порядка вычисления операндов. \killoverfullbefore

Присваивание также является выражением, и значением такого выражения является величина, которая присваивается. Помимо простого присваивания, существуют составные операции присваивания, которые выполняют дополнительные операции над своими операндами. \killoverfullbefore
%--------------------------------------------------------
% *******begin section***************
\section{\DbgSecSt{\StPart}{Операнды}}
\index{Выражения и присваивания!Операнды}

Операнд ~-- константа, литерал, идентификатор, вызов функции, индексное выражение, выражение выбора элемента или более сложное выражение, сформированное комбинацией операндов, знаков операций и круглых скобок.  \killoverfullbefore

Каждый операнд имеет тип. Тип операнда может быть явно преобразован к другому типу посредством операции приведения типа.  \killoverfullbefore 

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Идентификаторы}}
\index{Выражения и присваивания!Операнды!Идентификаторы}

Идентификаторы именуют переменные и функции. С каждым идентификатором ассоциируется тип, который задается при его объявлении. Значение объекта, именуемого идентификатором, зависит от типа следующим образом:
\begin{itemize}
\item идентификаторы объектов целых и плавающих типов представляют значения соответствующего типа;
\item идентификатор переменной перечислимого типа представляет значение одной константы из соответствующего этому типу списка перечисления, тип этого значения int;
\item идентификатор объекта типа struct или union представляет значение, определенное структурой или объединением;
\item идентификатор, объявляемый как указатель, представляет указатель на значение, заданное в объявлении типа;  
\item идентификатор, объявляемый как массив, представляет указатель, значение которого является адресом первого элемента массива, тип адресуемых указателем величин соответствует типу элементов массива;  
\item идентификатор, объявляемый как функция, представляет указатель, значение которого является адресом функции, возвращающей значения определенного типа.\killoverfullbefore 
\end{itemize}

Адрес массива не меняется при выполнении программы, хотя значения отдельных элементов массива могут меняться. Значение указателя, представленное идентификатором массива, не переменная, поэтому идентификатор массива не может стоять левым операндом в операции присвоения. 

Адрес функции не меняется в процессе выполнения программы, но возвращаемое значение может меняться. Таким образом идентификаторы функций не могут служить левыми операндами в операциях присвоения.
% *******end subsection***************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Константы и константные выражения}}
\index{Выражения и присваивания!Операнды!Константы}

Операнду-константе соответствует значение и тип представляющей его константы. 

Символьная константа имеет тип int. Целая константа имеет тип int, long, unsigned int или unsigned long в зависимости от размера величины и способа ее задания. Константы с плавающей точкой всегда имеют тип double. Строковые литералы считаются массивами символов. \killoverfullbefore 

%Любой операнд, который имеет константное значение, называется константным выражением. Если в качестве операнда используется константа, то ему соответствует значение и тип представляющей его константы.

Константное выражение — это выражение, результатом вычисления которого является константа. Операндами константного выражения могут быть целые, символьные, плавающие константы, константы перечислимого типа, выражения приведения типа константного выражения и другие константные выражения. \killoverfullbefore

В константных выражениях нельзя использовать операции присваивания, операцию последовательного вычисления. \killoverfullbefore
% *******end subsection***************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Символьные строки}}
\index{Выражения и присваивания!Операнды!Символьные строки}

\begin{pHeader}
Синтаксис:      & \RightHandText{"строка"["строка"]}\\
\end{pHeader}

Символьная строка состоит из последовательности символов, заключенных в двойные кавычки. Эта последовательность представляется в памяти как массив элементов типа char. Символьная строка представляет в выражении адрес этого массива, то есть адрес первого элемента строки. \killoverfullbefore 

Строки являются указателями, поэтому их и можно использовать, как указатели, и на них распространяются те же ограничения. Однако, это не переменные, поэтому ни строковые литералы, ни их элементы не могут быть левыми операндами в операции присвоения. \killoverfullbefore 

Следует помнить, что последним символом строки всегда является нулевой символ, который автоматически добавляется при хранении строки в памяти. \killoverfullbefore 
% *******end subsection***************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Вызовы функций}}
\index{Выражения и присваивания!Операнды!Вызовы функций}

\renewcommand{\arraystretch}{1.2} %% increase table row spacing
\renewcommand{\tabcolsep}{0.2cm}   %% increase table column spacing
\begin{pHeader}
Синтаксис:      & \RightHandText{выражение([список-выражений])}\\
\end{pHeader}

Вызов функции состоит из выражения, за которым стоит необязательный элемент [список-выражений] в круглых скобках.\killoverfullbefore 

Значением выражения должен быть адрес функции. В простейшем случае это идентификатор функции. Список выражений содержит выражения, разделенные запятыми. Значение каждого из этих выражений соответствует фактическому аргументу функции. Список выражений может быть пустым, если функция не имеет аргументов, однако наличие скобок и в этом случае обязательно. \killoverfullbefore 

Операнд, являющийся вызовом функции, имеет тип и значение возвращаемого функцией значения. \killoverfullbefore 
% *******end subsection***************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Индексные выражения}}
\index{Выражения и присваивания!Операнды!Индексные выражения}

\begin{pHeader}
Синтаксис:      & \RightHandText{выражение1 [выражение2]}\\
\end{pHeader}

Значение индексного выражения находится по адресу, который вычисляется как сумма значений выражения1 и выражения2. \killoverfullbefore 

Обычно выражение1 является указателем, например, идентификатором массива, а выражение2 ~-- целая величина. Однако требуется только, чтобы одно из выражений было указателем, а второе целочисленной величиной. Поэтому выражение1 может быть целочисленной величиной, а выражение2 указателем. Независимо от порядка следования  выражение2 должно быть заключено в квадратные скобки ([ ]). \killoverfullbefore 

Индексные выражения обычно используются для ссылки на элементы массива, но их можно использовать в качестве любого указателя.  \killoverfullbefore 

Индексные выражения для ссылки на элементы одномерного массива вычисляются путем сложения целой величины со значениями указателя с последующим применением к результату операции разадресации (*). \killoverfullbefore 

Так как одно из выражений, указанных в индексном выражении, является указателем, то при сложении используются правила адресной арифметики, согласно которым целая величина преобразуется к адресному представлению, путем умножения ее на размер типа, адресуемого указателем.\killoverfullbefore \BL

\clearpage

\index{Выражения и присваивания!Операнды!Многомерный массив}
\mylbl{Многомерный массив}{Multidimensional array} \BL

\begin{pHeader}
Синтаксис:      & \RightHandText{выражение1[выражение2][выражение3]...}\\
\end{pHeader}

Индексное выражение может иметь более одного индекса. Выражение с несколькими индексами ссылается на элементы многомерных массивов. Многомерный массив - это массив, элементами которого являются массивы. Например, первым элементом трехмерного массива является массив с двумя измерениями. \killoverfullbefore

Для ссылки на элемент многомерного массива индексное выражение должно иметь несколько индексов заключенных к квадратные скобки.\killoverfullbefore

Такое индексное выражение интерпретируется слева направо. Операция разадресации осуществляется после вычисления последнего индексного выражения. Отметим, что операция разадресации не применяется, если значение последнего указателя адресует величину типа массива. \killoverfullbefore
% *******end subsection***************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Выбор элемента}}
\index{Выражения и присваивания!Операнды!Выбор элемента}

\begin{pHeader}
Синтаксис:      & \RightHandText{выражение.идентификатор}\\
                & \RightHandText{выражение->идентификатор}\\
\end{pHeader}

Выражение выбора элемента применяется, если в качестве операнда надо использовать элемент структуры или объединения. Такое выражение имеет значение и тип выбранного элемента.\killoverfullbefore

Выражение выбора элемента может иметь одну из двух следующих форм: 
\begin{itemize}
\item выражение.идентификатор, в которой выражение соответствует значению типа struct или union, а идентификатор задает имя элемента указанной структуры или объединения;
\item выражение->идентификатор, в которой выражение соответствует указателю на структуру или объединение, а идентификатор задает имя элемента указанной структуры или объединения. 
\end{itemize}

% *******end subsection***************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Выражения в скобках}}
\index{Выражения и присваивания!Операнды!Выражения в скобках}

Любой операнд может быть заключен в круглые скобки. Скобки влияют на то, каким путем группируются операнды в выражении.\killoverfullbefore

% *******end subsection***************

%--------------------------------------------------------
% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Выражения с операторами}}
\index{Выражения и присваивания!Выражения с операторами}

\begin{pHeader}
Синтаксис:      & \RightHandText{унарный-оператор операнд}\\
                & \RightHandText{операнд бинарный-оператор операнд}\\
                & \RightHandText{операнд ? операнд : операнд}\\                
\end{pHeader}

Выражения с операторами могут участвовать в выражениях как операнды. Они могут быть унарными (с одним операндом), бинарными (с двумя операндами) и тернарными (с тремя операндами). \killoverfullbefore

Унарное выражение состоит либо из унарного оператора, который применяется к операнду. Бинарные выражения состоят из двух операндов, объединенных бинарным оператором. Тернарные выражения состоят из трех операндов, объединенных тернарным оператором ( ? : ).\killoverfullbefore

Выражения с операторами включают в себя также и выражения присвоения, которые используют унарные или бинарные операторы присвоения. Унарными операторами присвоения являются операторы увеличения (++) и уменьшения (--). Бинарными операторами присвоения являются оператор простого присвоения (=) и составные операторы присвоения. Каждый составной оператор присвоения является комбинацией других бинарных операторов с оператором простого присвоения. Выражения присвоения имеют следующий вид: 
\begin{itemize}
\item операнд++;
\item операнд{--}{-};
\item ++операнд;
\item {--}{--}операнд;
\item операнд=операнд;
\item операнд составной-оператор-присвоения операнд.
\end{itemize}

% *******end subsection***************

% *******end section*****************
%--------------------------------------------------------
% *******begin section***************
\section{\DbgSecSt{\StPart}{Операции}}
\index{Выражения и присваивания!Операции}

Любое выражение состоит из операндов, соединенных знаками операций. Знак операции - это символ или группа символов, которые сообщают о необходимости выполнения определенных арифметических, логических или других действий. 

Операции имеют либо один операнд (унарные операции), либо два операнда (бинарные операции), либо три (тернарная операция). Операция присваивания может быть как унарной, так и бинарной.\killoverfullbefore

Унарные операции приведены в табл.~\ref{tbl:UO}.

\begin{MyTableTwoColCntr}{Унарные операции}{tbl:UO}{|m{0.25\linewidth}|m{0.65\linewidth}|}{Знак операции}{Операция}
\hline \centering{{--}}    & арифметическое отрицание (отрицание и дополнение) \\
\hline \centering {\textasciitilde}   & побитовое логическое отрицание (дополнение) \\
\hline  \centering {!}  & логическое отрицание \\
\hline  \centering {*} & разадресация (косвенная адресация) \\
\hline \centering {\&} & вычисление адреса \\
\hline \centering {+} & унарный плюс \\
\hline \centering {++} & увеличение (инкремент) \\
\hline \centering {{--}{--}} & уменьшение (декремент) \\
\end{MyTableTwoColCntr}

Унарные операции выполняются справа налево. \killoverfullbefore

Операции увеличения и уменьшения увеличивают или уменьшают значение операнда на единицу и могут быть записаны как справа так и слева от операнда. \killoverfullbefore

Если знак операции записан перед операндом (префиксная форма), то изменение операнда происходит до его использования в выражении. Если знак операции записан после операнда (постфиксная форма), то операнд вначале используется в выражении, а затем происходит его изменение. \killoverfullbefore \BL

Бинарные операции приведены в табл.~\ref{tbl:BO}.

\begin{center}%
        \begin{longtable}{|m{0.25\linewidth}|>{\centering}m{0.15\linewidth}|m{0.55\linewidth}|}
        \caption{Бинарные операции}\label{tbl:BO}\\ 
    \hline  
            &       &         \\
            \TB{\textbf{Группа операций}} &  
            \textbf{Знак операции} & \textbf{Операция} \TBend 
            &       &        \\
\hline

\hline  Мультипликативные       & * & умножение \\ \cline{2-3}
                        & / & деление \\ \cline{2-3}
                        & \% & остаток от деления \\                         
                        
\hline  Аддитивные      & + & сложение \\ \cline{2-3}
                        & {--} & вычитание \\ 

\hline  Операции сдвига & $\ll$ & сдвиг влево \\ \cline{2-3}
                        & $\gg$ & сдвиг вправо \\ 
   
\hline Операции         & < & меньше \\ \cline{2-3}
отношения               & <= & меньше или равно \\ \cline{2-3}
                        & > & больше \\ \cline{2-3} 
                        & >= & больше или равно \\ \cline{2-3}                        
                        & == & равно \\ \cline{2-3}                           
                        & != & не равно \\   
                        
\hline Поразрядные      & \& & поразрядное И \\ \cline{2-3}
операции                & $\vert$ & поразрядное ИЛИ \\ \cline{2-3}
                        & \textasciicircum & поразрядное исключающее ИЛИ \\  
 
\hline   Операция последовательного вычисления     & , & последовательное вычисление \\

\hline  Операции        & = & присваивание \\ \cline{2-3}
присваивания            & *= & умножение с присваиванием \\ \cline{2-3}
                        & /= & деление с присваиванием \\ \cline{2-3} 
                        & \%= & остаток от деления с присваиванием \\ \cline{2-3}                        
                        & {--}= & вычитание с присваиванием \\ \cline{2-3}                           
                        & += & сложение с присваиванием \\   \cline{2-3} 
                        & $\ll$= & сдвиг влево с присваиванием \\   \cline{2-3} 
                        & $\gg$= & сдвиг вправо с присваиванием \\  \cline{2-3}   
                        & \&= & поразрядное И с присваиванием \\ \cline{2-3} 
                        & $\vert$= & поразрядное ИЛИ с присваиванием \\ \cline{2-3} 
                        & \textasciicircum= & поразрядное исключающее ИЛИ с присваиванием \\
\hline
\end{longtable}
\end{center}%

В отличие от унарных, бинарные операции выполняются слева направо. 

Левый операнд операции присваивания должен быть выражением, ссылающимся на область памяти (но не объектом объявленным с ключевым словом const), такие выражения называются леводопустимыми к ним относятся: 
\begin{itemize}
\item идентификаторы данных целого и плавающего типов, типов указателя, структуры, объединения; 
\item индексные выражения, исключая выражения имеющие тип массива или функции; 
\item индексные выражения, исключая выражения имеющие тип массива или функции; 
\item выражения выбора элемента (->) и (.), если выбранный элемент является леводопустимым; 
\item выражения унарной операции разадресации (*), за исключением выражений, ссылающихся на массив или функцию; 
\item выражение приведения типа, если результирующий тип не превышает размера первоначального типа. \killoverfullbefore \BL
\end{itemize}

Тернарное выражение состоит из трех операндов, разделенных знаками тернарной операции (?) и (:), и имеет вид: <операнд1>?<операнд2>:<операнд3>.

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Преобразования при вычислении выражений}}
\index{Выражения и присваивания!Преобразования при вычислении выражений}

При выполнении операций производится автоматическое преобразование типов, чтобы привести операнды выражений к общему типу или чтобы расширить короткие величины до размера целых величин. Выполнение преобразования зависит от специфики операций и от типа операнда или операндов. 

Если в выражении появляются операнды различных типов, то они преобразуются к некоторому общему типу, при этом к каждому арифметическому операнду применяется следующая последовательность правил:
\begin{itemize}
\item Если один из операндов в выражении имеет тип double, то остальные тоже преобразуются к типу double.
\item В противном случае, если один из операндов в выражении имеет тип float, то остальные тоже преобразуются к типу float.
\item В противном случае, если один из операндов в выражении имеет тип unsigned long, то остальные тоже преобразуются к типу unsigned long.
\item В противном случае, если один из операндов в выражении имеет тип long, то остальные тоже преобразуются к типу long.
\item В противном случае, если один из операндов в выражении имеет тип unsigned, то остальные тоже преобразуются к типу unsigned.
\item В противном случае все операнды преобразуются к типу int. При этом тип char преобразуется в int со знаком; тип unsigned char в int, у которого старший байт всегда нулевой; тип signed char в int, у которого в знаковый разряд передается знак из сhar; тип short в int (знаковый или беззнаковый). \BL
\end{itemize}

Предположим, что вычислено значение некоторого выражения в правой части оператора присваивания. В левой части оператора присваивания записана некоторая переменная, причем ее тип отличается от типа результата в правой части. Здесь правила преобразования очень простые: значение справа от оператора присваивания преобразуется к типу переменной слева от оператора присваивания. Если размер результата в правой части больше размера операнда в левой части, то старшая часть этого результата будет потеряна. \killoverfullbefore
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Операции отрицания и дополнения}}
\index{Выражения и присваивания!Операции отрицания и дополнения}

Операция арифметического отрицания ({--}) вырабатывает отрицание своего операнда. Операнд должен быть целой или плавающей величиной. При выполнении осуществляются обычные арифметические преобразования. \killoverfullbefore

Операция логического отрицания <<НЕ>> (!) вырабатывает значение 0, если операнд есть истина (не ноль), и значение 1, если операнд равен нулю. Результат имеет тип int. Операнд должен быть целого или плавающего типа или типа указатель. \killoverfullbefore

Операция двоичного дополнения (\textasciitilde) вырабатывает двоичное дополнение своего операнда. Операнд должен быть целого типа. Осуществляется обычное арифметическое преобразование, результат имеет тип операнда после преобразования. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:NegCompOperation}
\begin{tabular}{ l l }
double u = 5; & \textcolor{exComm}{/* Объявление переменной типа double */} \\
u = {--}u;  & \textcolor{exComm}{/* Переменной u присваивается ее отрицание,  */} \\
\vdots & \textcolor{exComm}{/* u  принимает значение -5 */} \\
int t, z=0;  & \textcolor{exComm}{/* Объявление переменных типа int */} \\
t=!z;  & \textcolor{exComm}{/* Переменная t получает значение равное 1, так как */} \\
\vdots & \textcolor{exComm}{/* переменная z имела значение 0 */} \\
unsigned char  b = 0x39, f; & \textcolor{exComm}{/* Объявление переменных типа unsigned char */} \\
\vdots & \textcolor{exComm}{/* Значение b в двоичном представлении 0011 1001 */} \\
f = \textasciitilde b; & \textcolor{exComm}{/* Переменной f присваивается значение 0xС6 или  */} \\
\vdots & \textcolor{exComm}{/* 1100 0110 в двоичном представлении */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Операции разадресации и адреса}}
\index{Выражения и присваивания!Операции разадресации и адреса}

Операции разадресации и адреса используются для работы с переменными типа указатель. \killoverfullbefore

Операция разадресации (*) осуществляет косвенный доступ к адресуемой величине через указатель. Операнд должен быть указателем. Результатом операции является величина, на которую указывает операнд. Типом результата является тип величины, адресуемой указателем. Результат не определен, если указатель содержит недопустимый адрес. \killoverfullbefore

Указатель содержит недопустимый адрес, когда:
\begin{itemize}
\item является нулевым;  
\item определяет адрес такого объекта, который не является активным в момент ссылки;  
\item определяет адрес, который не выровнен до типа объекта, на который он указывает; 
\item определяет адрес, не используемый выполняющейся программой. \killoverfullbefore \BL
\end{itemize}

Операция адрес (\&) дает адрес своего операнда. Операндом может быть любое именуемое выражение. Имя функции или массива также может быть операндом операции адрес, хотя в этом случае знак операции является лишним, так как имена массивов и функций являются адресами. Результатом операции адрес является указатель на операнд. Тип, адресуемый указателем, является типом операнда. \killoverfullbefore

Операция адрес не может применяться к элементам структуры, являющимися полями битов.\killoverfullbefore \BL

\clearpage

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:ShiftOperation}
\begin{tabular}{ l l }
int *pa, x; & \textcolor{exComm}{/* Объявление указателя и переменной типа int */} \\
int a[20]; & \textcolor{exComm}{/* Объявление массива типа int */} \\
double d; & \textcolor{exComm}{/* Объявление переменной типа double */} \\
\vdots  & \textcolor{exComm}{ } \\
pa = \&a[5];  & \textcolor{exComm}{/* В указатель pa записывается адрес шестого элемента */} \\
\vdots  & \textcolor{exComm}{/* массива a */} \\
d = *(double *)(\&x); & \textcolor{exComm}{/* Адрес x приведением типа преобразуется в указатель */} \\
\vdots & \textcolor{exComm}{/* типа double, затем применение оператора адресации дает  */} \\
\vdots  & \textcolor{exComm}{/* результат типа double */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Мультипликативные операции}}
\index{Выражения и присваивания!Мультипликативные операции}

К мультипликативным операциям относятся операции умножения (*), деления (/) и получение остатка от деления (\%). \killoverfullbefore

Операция умножения (*) выполняет умножение операндов. \killoverfullbefore

Операция деления (/) выполняет деление первого операнда на второй. Если две целые величины не делятся без остатка, то результат округляется до меньшего целого значения. \killoverfullbefore

Отметим, что типы операндов операций умножения и деления могут отличаться, и для них справедливы правила преобразования типов. Типом результата является тип операндов после преобразования. \killoverfullbefore 

Операция остаток от деления (\%) дает остаток от деления первого операнда на второй. Операндами операции (\%) должны быть целые числа. Знак результата совпадает со знаком делимого. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:MultOperations}
\begin{tabular}{ l l }
int  i=5, j=10, m, k; & \textcolor{exComm}{/* Объявление переменной типа int */} \\
float f=0.2; & \textcolor{exComm}{/* Объявление переменной типа float */} \\
double d=f*i; & \textcolor{exComm}{/* Тип произведения i и f преобразуется к типу double, */} \\
\vdots  & \textcolor{exComm}{/* затем результат присваивается переменной d */} \\
m = j/({--}i); & \textcolor{exComm}{/* Переменной m присваивается значение -2 */} \\
\vdots  & \textcolor{exComm}{ } \\
k = (i+j)\%m; & \textcolor{exComm}{/* Переменной k присваивается значение 1 */} \\
k = {--}(i+j)\%m; & \textcolor{exComm}{/* Переменной k присваивается значение -1 */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Аддитивные операции}}
\index{Выражения и присваивания!Аддитивные операции}

К аддитивным операциям относятся сложение (+) и вычитание ({--}). \killoverfullbefore

Операнды могут быть целого или плавающего типов. В некоторых случаях над операндами аддитивных операций выполняются общие арифметические преобразования. Однако преобразования, выполняемые при аддитивных операциях, не обеспечивают обработку ситуаций переполнения и потери значимости. Информация теряется, если результат аддитивной операции не может быть представлен типом операндов после преобразования. \killoverfullbefore

Результатом выполнения операции сложения является сумма двух операндов. Операнды могут быть целого или плавающего типа или один операнд может быть указателем, а второй - целой величиной. \killoverfullbefore

Когда целая величина складывается с указателем, то целая величина преобразуется путем умножения ее на размер памяти, занимаемой величиной, адресуемой указателем. \killoverfullbefore

Когда преобразованная целая величина складывается с величиной указателя, то результатом является указатель, адресующий ячейку памяти, расположенную на целую величину дальше от исходного адреса. Новое значение указателя адресует тот же самый тип данных, что и исходный указатель. \killoverfullbefore \BL

Операция вычитания ({--}) вычитает второй операнд из первого. Возможна следующая комбинация операндов: 
\begin{itemize}
\item оба операнда целого или плавающего типа;  
\item оба операнда являются указателями на один и тот же тип;  
\item первый операнд является указателем, а второй ~-- целым. \killoverfullbefore \BL
\end{itemize}

Операции сложения и вычитания над адресами в единицах, отличных от длины типа, могут привести к непредсказуемым результатам.\killoverfullbefore \BL 

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:AddOperations}
\begin{tabular}{ l l }
short i=30000, j=30000, k;  & \textcolor{exComm}{/* Объявление переменных типа short */} \\
k=i+j;  & \textcolor{exComm}{/* В результате сложения k значение равно -5536 */} \\
\vdots  & \textcolor{exComm}{ } \\
double d[10], *u; & \textcolor{exComm}{/* Объявление массива и указателя типа double */} \\
int i;  & \textcolor{exComm}{/* Объявление переменной типа int */} \\
u = d+2; & \textcolor{exComm}{/* Переменная u указывает на третий элемент массива */} \\
i = u{--}d; & \textcolor{exComm}{/* Переменная i принимает значение 2 */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

\clearpage

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Операции сдвига}}
\index{Выражения и присваивания!Операции сдвига}

Операции сдвига осуществляют смещение операнда влево ($\ll$) или вправо ($\gg$) на число битов, задаваемое вторым операндом. \killoverfullbefore

Оба операнда должны быть целыми величинами. Выполняются обычные арифметические преобразования. При сдвиге влево правые освобождающиеся биты устанавливаются в нуль. При сдвиге вправо метод заполнения освобождающихся левых битов зависит от типа первого операнда. Если тип unsigned, то свободные левые биты устанавливаются в нуль. В противном случае они заполняются копией знакового бита. Результат операции сдвига не определен, если второй операнд отрицательный. \killoverfullbefore

Преобразования, выполненные операциями сдвига, не обеспечивают обработку ситуаций переполнения и потери значимости. Информация теряется, если результат операции сдвига не может быть представлен типом первого операнда, после преобразования. \killoverfullbefore

Отметим, что сдвиг влево соответствует умножению первого операнда на степень числа 2, равную второму операнду, а сдвиг вправо соответствует делению первого операнда на 2 в степени, равной второму операнду. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:ShiftOperation}
\begin{tabular}{ l l }
int  i=0x1234, j,  k; & \textcolor{exComm}{/* Объявление переменных типа int */} \\
k = i$\ll$4; & \textcolor{exComm}{/* k в шестнадцатеричном представлении равно 0x0234 */} \\
j = i$\ll$8; & \textcolor{exComm}{/* j в шестнадцатеричном представлении равно 0x3400 */} \\
i = j$\gg$8;  & \textcolor{exComm}{/* i в шестнадцатеричном представлении равно 0x0034 */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Операции отношения}}
\index{Выражения и присваивания!Операции отношения}

Операции отношения сравнивают первый операнд со вторым и вырабатывают значение 1 (истина) или 0 (ложь). Результат имеет тип int. \killoverfullbefore

Операнды могут иметь целый, плавающий тип, либо быть указателями. Типы первого и второго операндов могут различаться. Над операндами выполняются преобразования по умолчанию.\killoverfullbefore

Операндами любой операции отношения могут быть два указателя на один и тот же тип. Для операции проверки на равенство или неравенство результат сравнения означает, указывают ли оба указателя на одну и ту же ячейку памяти или нет. Результат сравнения указателей для других операций (<, >, <=, >=) отражает относительное положение двух адресов памяти.\killoverfullbefore

Сравнение адресов различных элементов одного и того же массива может быть полезным, поскольку элементы массива хранятся в памяти последовательно. Адрес предшествующего элемента массива всегда меньше, чем адрес последующего элемента.\killoverfullbefore

Указатель можно проверять на равенство или неравенство константе NULL (ноль). Указатель, имеющий значение NULL, не указывает ни на какую область памяти. Он называется нулевым указателем.\killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:RelationalOperations}
\begin{tabular}{ l l }
int х, у; & \textcolor{exComm}{/* Объявление переменных типа int */} \\
х = 2; у = 2; & \textcolor{exComm}{ } \\
х < у; & \textcolor{exComm}{/* Выражение имеет значение 0 */} \\
у > х; & \textcolor{exComm}{/* Выражение имеет значение 0 */} \\
x <= у;  & \textcolor{exComm}{/* Выражение имеет значение 1 */} \\
x >= у;  & \textcolor{exComm}{/* Выражение имеет значение 1 */} \\
x == у;  & \textcolor{exComm}{/* Выражение имеет значение 1 */} \\
x != у;  & \textcolor{exComm}{/* Выражение имеет значение 0 */} \\  
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Поразрядные операции}}
\index{Выражения и присваивания!Поразрядные операции}

К поразрядным операциям относятся: операция поразрядного логического <<И>> (\&), операция поразрядного логического <<ИЛИ>> ($\vert$), операция поразрядного <<исключающего ИЛИ>>  (\textasciicircum). \killoverfullbefore

Операнды поразрядных операций могут быть любого целого типа. При необходимости над операндами выполняются преобразования по умолчанию, тип результата - это тип операндов после преобразования. \killoverfullbefore

Операция поразрядного логического <<И>> (\&) сравнивает каждый бит первого операнда с соответствующим битом второго операнда. Если оба сравниваемых бита единицы, то соответствующий бит результата устанавливается в 1, в противном случае в 0. \killoverfullbefore

Операция поразрядного логического <<ИЛИ>> ($\vert$) сравнивает каждый бит первого операнда с соответствующим битом второго операнда. Если любой (или оба) из сравниваемых битов равен 1, то соответствующий бит результата устанавливается в 1, в противном случае результирующий бит равен 0. \killoverfullbefore

Операция поразрядного <<исключающего ИЛИ>> (\textasciicircum) сравнивает каждый бит первого операнда с соответствующими битами второго операнда. Если один из сравниваемых битов равен 0, а второй бит равен 1, то соответствующий бит результата устанавливается в 1, в противном случае, то есть когда оба бита равны 1 или 0, бит результата устанавливается в 0. \killoverfullbefore \BL 

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:BitwiseOperation}
\begin{tabular}{ l l }
int  i=0x45FF, & \textcolor{exComm}{/* i в двоичном представлении 0100 0101 1111 1111 */} \\
j=0x00FF; & \textcolor{exComm}{/* j в двоичном представлении 0000 0000 1111 1111 */} \\
char r; & \textcolor{exComm}{/* Объявление переменной типа char */} \\
r = i\&j;  & \textcolor{exComm}{/* r в шестнадцатеричном представлении 0x00FF, */} \\
\vdots & \textcolor{exComm}{/* в двоичном представлении 0000 0000 1111 1111 */} \\
\end{tabular}

\begin{tabular}{ l l }
r = i$\vert$j;  & \textcolor{exComm}{/* r в шестнадцатеричном представлении 0x45FF, */} \\
\vdots  & \textcolor{exComm}{/* в двоичном представлении 0100 0101 0000 0000 */} \\
r = i \textasciicircum j;  & \textcolor{exComm}{/* r в шестнадцатеричном представлении 0x4500, */} \\
\vdots  & \textcolor{exComm}{/* в двоичном представлении 0100 0101 0000 0000 */} \\
\end{tabular}
\end{pExample}
% *******end section*****************
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Логические операции}}
\index{Выражения и присваивания!Логические операции}

К логическим операциям относятся операция логического <<И>> (\&\&) и операция логического <<ИЛИ>> ($\vert$$\vert$). Операнды логических операций могут быть целого типа, плавающего типа или типа указателя, при этом в каждой операции могут участвовать операнды различных типов. \killoverfullbefore

Операнды логических выражений вычисляются слева направо. Если значения первого операнда достаточно, чтобы определить результат операции, то второй операнд не вычисляется. \killoverfullbefore

Логические операции не вызывают стандартных арифметических преобразований. Они оценивают каждый операнд с точки зрения его эквивалентности нулю. Результатом логической операции является 0 или 1, тип результата int. \killoverfullbefore

Операция логического <<И>> (\&\&) вырабатывает значение 1, если оба операнда имеют нулевые значения. Если один из операндов равен 0, то результат также равен 0. Если значение первого операнда равно 0, то второй операнд не вычисляется. \killoverfullbefore

Операция логического <<ИЛИ>> ($\vert$$\vert$) выполняет над операндами операцию <<включающего ИЛИ>>. Она вырабатывает значение 0, если оба операнда имеют значение 0, если какой-либо из операндов имеет ненулевое значение, то результат операции равен 1. Если первый операнд имеет ненулевое значение, то второй операнд не вычисляется. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:LogicalOperations}
\begin{tabular}{ l l }
int х, у, z; & \textcolor{exComm}{/* Объявление переменных типа int */} \\
\vdots & \textcolor{exComm}{ } \\
if(х<у \&\& у<z) \{ & \textcolor{exComm}{/* Тело оператора if выполняется, если x меньше y, и y меньше z */} \\
\vdots & \textcolor{exComm}{/* Если x больше y, то второй операнд (y<z) не вычисляется */} \\
\} & \textcolor{exComm}{ } \\
\vdots & \textcolor{exComm}{ } \\
if(х==у $\vert$$\vert$ х==z) \{ & \textcolor{exComm}{/*  Тело оператора if выполняется, если х равен у или z */} \\
\vdots & \textcolor{exComm}{/* Если х равен у, то второй операнд (х==z) не вычисляется */} \\
\} & \textcolor{exComm}{ } \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Операция последовательного вычисления}}
\index{Выражения и присваивания!Операция последовательного вычисления}

Операция последовательного вычисления обозначается запятой (,) и используется для вычисления двух и более выражений там, где по синтаксису допустимо только одно выражение. Данная операция вычисляет два операнда слева направо. \killoverfullbefore

При выполнении операции последовательного вычисления, преобразование типов не производится. Операнды могут быть любых типов. Результат операции имеет значения и тип второго операнда. \killoverfullbefore

Отметим, что запятая может использоваться также как символ разделитель, поэтому необходимо по контексту различать запятую, используемую в качестве разделителя или знака операции. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:SequentialOperations}
\begin{tabular}{ l l }
for (i=j=1; i+j<20; i+=i, j{--}{--}); & \textcolor{exComm}{/* Операнды i+=i и j{--}{--} оператора for вычисляется */} \\
\vdots & \textcolor{exComm}{/* независимо: сначала левый (i+=i), затем правый (j{--}{--}) */} \\
func(x, y+2, z); & \textcolor{exComm}{/* В вызове функции func передаются три аргумента,  */} \\
\vdots & \textcolor{exComm}{/* разделенные запятыми: x, y+2 и z */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Условная операция}}
\index{Выражения и присваивания!Условная операция}

Условная операция ~-- тернарная операция, которая имеет следующий формат: <операнд1>?<операнд2>:<операнд3>.\killoverfullbefore

<Операнд1> должен быть целого или плавающего типа или быть указателем. Он оценивается с точки зрения его эквивалентности 0. Если <операнд1> не равен 0, то вычисляется <операнд2> и его значение является результатом операции. Если <операнд1> равен 0, то вычисляется <операнд3> и его значение является результатом операции. Следует отметить, что вычисляется либо <операнд2>, либо <операнд3>, но не оба. \killoverfullbefore

Тип результата зависит от типов <операнда2> и <операнда3>, следующим образом: 
\begin{itemize}
\item если оба операнда имеют целый или плавающий тип (их типы могут отличаться), то выполняются обычные арифметические преобразования. Типом результата является тип операнда после преобразования. 
\item  если оба операнда имеют один и тот же тип структуры, объединения или указателя, то тип результата будет тем же самым типом структуры, объединения или указателя. 
\item если оба операнда имеют тип void, то результат имеет тип void. 
\item если один операнд является указателем на объект любого типа, а другой операнд является указателем на void, то указатель на объект преобразуется к указателю на void, который и будет типом результата.  
\item если один из операндов является указателем, а другой константным выражением со значением 0, то типом результата будет тип указателя. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:ConditionalOperation}
\begin{tabular}{ l l }
c = (d<=b) ? b : d; & \textcolor{exComm}{/* Переменной c присваивается максимальное */} \\
\vdots & \textcolor{exComm}{/* значение переменных d и b */} \\
void func1(void); & \textcolor{exComm}{/* Объявление функции func1 */} \\  
void func2(void); & \textcolor{exComm}{/* Объявление функции func2  */} \\
int x, y; & \textcolor{exComm}{/* Объявление переменных типа int  */} \\
\vdots & \textcolor{exComm}{ } \\
(x==y) ? (func1()) : (func2()); & \textcolor{exComm}{/* Если х равно у, то выполняется функция func1,   */} \\
\vdots & \textcolor{exComm}{/* иначе выполняется  функция func2   */} \\
\end{tabular}
\end{pExample}
\end{itemize}
% *******end subsection*****************
%--------------------------------------------------------

% *******begin subsection***************
\subsection{\DbgSecSt{\StPart}{Операции увеличения и уменьшения}}
\index{Выражения и присваивания!Операции увеличения и уменьшения}

Операции увеличения (++) и уменьшения ({--}{--}) являются унарными операциями присваивания. Они соответственно увеличивают или уменьшают значения операнда на единицу. 

Операнд может быть целого или плавающего типа или типа указатель и должен быть модифицируемым. Операнд целого или плавающего типа увеличиваются (уменьшаются) на единицу. Тип результата соответствует типу операнда. Операнд адресного типа увеличивается или уменьшается на размер объекта, который он адресует. \killoverfullbefore

Допускается префиксная или постфиксная формы операций увеличения (уменьшения), поэтому значения выражения, использующего операции увеличения (уменьшения) зависит от того, какая из форм указанных операций используется. \killoverfullbefore

Если знак операции стоит перед операндом (префиксная форма записи), то изменение операнда происходит до его использования в выражении и результатом операции является увеличенное или уменьшенное значение операнда. \killoverfullbefore

В том случае если знак операции стоит после операнда (постфиксная форма записи), то операнд вначале используется для вычисления выражения, а затем происходит изменение операнда. \killoverfullbefore 

В случае, если операции увеличения и уменьшения используются как самостоятельные операторы, префиксная и постфиксная формы записи становятся эквивалентными. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:IncDecOperations}
\begin{tabular}{ l l }
int t=1, s=2, z, f; & \textcolor{exComm}{/* Объявление переменных типа int */} \\
z=(t++)*5; & \textcolor{exComm}{/* Сначала происходит операция умножения t*5, а затем   */} \\
\vdots & \textcolor{exComm}{/* увеличение t. В результате z=5, t=2 */} \\
f=(++s)/3; & \textcolor{exComm}{/* Сначала значение s увеличивается, а затем используется  */} \\
\vdots & \textcolor{exComm}{/* в операции деления. В результате s=3, f=1 */} \\
z++; ++z;  & \textcolor{exComm}{/* Эквивалентные операции */} \\
\end{tabular}
\end{pExample}
% *******end subsection*****************
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Простое присваивание}}
\index{Выражения и присваивания!Простое присваивание}

Операция простого присваивания используется для замены значения левого операнда, значением правого операнда. При присваивании производится преобразование типа правого операнда к типу левого операнда по правилам, упомянутым раньше. Левый операнд должен быть модифицируемым. \killoverfullbefore \BL 

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:SimpleAssignment}
\begin{tabular}{ l l }
int t; & \textcolor{exComm}{/* Объявление переменной типа int */} \\
char f; & \textcolor{exComm}{/* Объявление переменной типа char */} \\
long z; & \textcolor{exComm}{/* Объявление переменной типа long */} \\
t=f+z;  & \textcolor{exComm}{/* Значение переменной f преобразуется к типу long, вычисляется*/} \\
\vdots & \textcolor{exComm}{/* сумма f+z, результат преобразуется к типу int и затем */} \\
\vdots & \textcolor{exComm}{/*  присваивается переменной t */} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Составное присваивание}}
\index{Выражения и присваивания!Составное присваивание}

Имеется целая группа операций присваивания, которые объединяют простое присваивание с одной из бинарных операций. \killoverfullbefore

Такие операции называются составными операциями присваивания и имеют вид: <операнд1> <бинарная операция> = <операнд2>. \killoverfullbefore

Составное присваивание по результату эквивалентно следующему простому присваиванию: <операнд1> = <операнд1> <бинарная операция> <операнд2>. \killoverfullbefore

Выражение составного присваивания с точки зрения реализации не эквивалентно простому присваиванию, так как в последнем операнд1 вычисляется дважды. \killoverfullbefore

Каждая операция составного присваивания выполняет преобразования, которые осуществляются соответствующей бинарной операцией. Левым операндом операций (+=) ({--}=) может быть указатель, в то время как правый операнд должен быть целым числом. \killoverfullbefore \BL 

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:CompoundAssignment}
\begin{tabular}{ l l }
double  arr[4]=\{2.0, 3.3, 5.2, 7.5\};
 & \textcolor{exComm}{/* Объявление массива типа double */} \\
double  b=3.0; & \textcolor{exComm}{/* Объявление переменной типа double */} \\
b+=arr[2]; & \textcolor{exComm}{/* Эквивалентно b=b+arr[2] */} \\
arr[3]/=b+1;  & \textcolor{exComm}{/* Эквивалентно arr[3]=arr[3]/(b+1) */} \\
\vdots & \textcolor{exComm}{ } \\
unsigned int n; & \textcolor{exComm}{/* Объявление переменной типа unsigned int */} \\
\end{tabular}

\begin{tabular}{ l l }
\vdots & \textcolor{exComm}{ } \\
n\&= 0xFFFE; & \textcolor{exComm}{ /* Операция поразрядное И выполняется над n и */} \\
\vdots & \textcolor{exComm}{ /* результат присваивается n */} \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Приоритеты операций и порядок вычислений}}
\index{Выражения и присваивания!Приоритеты операций и порядок вычислений}

Операции выполняются в строгой последовательности. Величина, определяющая преимущественное право на выполнение той или иной операции, называется приоритетом. Операции с высшими приоритетами вычисляются первыми. Наивысшим приоритетом является приоритет равный 1. Приоритеты и порядок операций приведены в табл.~\ref{tbl:Priorities}. Порядок выполнения операций может регулироваться с помощью круглых скобок. 

\begin{MyTableFourCol}{Приоритеты и порядок операций}{tbl:Priorities}{|m{0.14\linewidth}|m{0.32\linewidth}|m{0.24\linewidth}|m{0.18\linewidth}|}{Приоритет}{Знак операции}{Типы операции}{Порядок \newline выполнения}
\hline \centering {1}  & ( ) [ ] . ->  & Выражение  & Слева направо \\
\hline \centering {2}  & {--} \textasciitilde { } ! * \& ++ {--}{--}  приведение типов   & Унарные  & Справа налево \\
\hline \centering {3}  & * / \%  & Мультипликативные  & Слева направо \\
\hline \centering {4}  & + {--}  & Аддитивные  & Слева направо \\
\hline \centering {5}  & $\ll$ $\gg$  & Сдвиг  & Слева направо  \\
\hline \centering {6}  & < > <= >=  & Отношение  & Слева направо \\
\hline \centering {7} & == !=   & Отношение (равенство)  & Слева направо \\
\hline \centering {8} &  \& & Поразрядное И & Слева направо \\
\hline \centering {9} & \textasciicircum  & Поразрядное исключающее ИЛИ & Слева направо \\
\hline \centering {10} & $\vert$  & Поразрядное ИЛИ & Слева направо \\
\hline \centering {11} & \&\&  & Логическое И & Слева направо \\
\hline \centering {12} & $\vert$ $\vert$ & Логическое ИЛИ & Слева направо \\
\hline \centering {13} & ?{ }: & Условная & Слева направо \\
\hline \centering {14} & = *= /= \%= += {--}= \&= {$\vert$=} $\gg$= $\ll$= \textasciicircum= & Простое и составное присваивание & Справа налево \\
\hline \centering {15} & , & Последовательное вычисление & Слева направо \\
\end{MyTableFourCol}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Побочные эффекты}}
\index{Выражения и присваивания!Побочные эффекты}

Побочный эффект выражается в неявном изменении значения переменной в процессе вычисления выражения. Все операции присваивания могут вызывать побочный эффект. 

Вызов функции, в которой изменяется значение какой-либо внешней переменной, либо путем явного присваивания, либо через указатель, также имеет побочный эффект.

Унарные операции инкремента и декремента также содержат в себе присваивание и могут быть причиной побочных эффектов. \killoverfullbefore \BL

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:SideEffects}
\begin{tabular}{ l l }
add(i + 1, i = j + 2); & \textcolor{exComm}{/* Аргументы вызова функции add могут быть вычислены */} \\
\vdots & \textcolor{exComm}{/* в любом порядке, то есть выражение i+1 может быть */} \\
\vdots & \textcolor{exComm}{/* вычислено перед выражением i=j+2 или после него */} \\
\vdots & \textcolor{exComm}{ } \\
int i, а [10]; & \textcolor{exComm}{ } \\
i = 0;  & \textcolor{exComm}{ } \\
a[i++] = i; & \textcolor{exComm}{/* Элементу а[0] будет присвоено значение 0 или 1 */ } \\
\end{tabular}
\end{pExample}
% *******end section*****************
%--------------------------------------------------------

% *******begin section***************
\section{\DbgSecSt{\StPart}{Преобразование типов}}
\index{Выражения и присваивания!Преобразование типов}

При выполнении операций происходят неявные преобразования типов в следующих случаях: 
\begin{itemize}
\item при выполнении операций осуществляются обычные арифметические преобразования (которые были рассмотрены выше);  
\item при выполнении операций присваивания, если значение одного типа присваивается переменной другого типа;
\item при передаче аргументов функции. \killoverfullbefore \BL  
\end{itemize}

\begin{comment}
В операциях присвоения тип присваиваемого значение преобразуется в тип переменной, которой делается присвоение.  Допускается преобразование типов при присвоении между интегральными типами и типами с плавающей точкой, даже если при преобразовании происходит потеря информации.

Целая со знаком преобразуется в более короткую целую со знаком путем отбрасывания старших битов и в большую целую со знаком за счет расширения знака. 

Когда целая со знаком преобразуется в целую без знака, значение целой со знаком преобразуется к размеру целого без знака и результат интерпретируется, как значение без знака. 

Не происходит потери информации при преобразовании целой со знаком в значение с плавающей точкой.

Целое без знака преобразуется в более короткое целое со знаком или без знака отбрасыванием битов старшего порядка или в большее целое со знаком или без знака дополнением нулей. 

Когда целое без знака преобразуется в целое со знаком того же размера, битовый состав не меняется. Однако представляемое им значение меняется, если бит знака установлен. 

При преобразовании целого без знака в величину с плавающей точкой оно сначала преобразуется в значение long со знаком, а затем значение long со знаком преобразуется в величину с плавающей точкой. 

Преобразование из типа float в тип double не вносит каких-либо изменений в значение. Преобразование значения из double в float происходит явно, если оно возможно. 

При преобразовании величины с плавающей точкой в интегральное значение она сначала преобразуется в тип long, а затем из типа long в конкретный интегральный тип.

Указатель на один тип значения может быть преобразован в указатель на другой тип. Однако, при этом можно получить неопределенный результат из-за требований к выравниванию и размерам различных типов в памяти. 

Указатель типа void может быть преобразован в любой тип и в него может быть преобразован любой тип, без каких-либо ограничений. 

Тип enum по определению имеет значение int, поэтому преобразование из этого типа и в этот тип будет таким же, как и для int. 

Не допускается преобразование между типами структуры и объединения. 
\end{comment}

В операциях присваивания тип значения, которое присваивается, преобразуется к типу переменной, получающей это значение. Допускается преобразования целых и плавающих типов, даже если такое преобразование ведет к потере информации. \killoverfullbefore \BL 

\clearpage

\index{Выражения и присваивания!Преобразование типов!Преобразование целых типов}
\mylbl{Преобразование целых типов}{TypeConversionInt} \BL

Целое со знаком преобразуется к более короткому целому со знаком, посредством усечения старших битов. Целая со знаком преобразуется к более длинному целому со знаком, путем размножения знака. При преобразовании целого со знаком к целому без знака, целое со знаком преобразуется к размеру целого без знака и результат рассматривается как значение без знака. 

Преобразование целого со знаком к плавающему типу происходит без потери информации, за исключением случая преобразования значения типа long int или unsigned long int к типу float, когда точность может быть потеряна. 

Целое без знака преобразуется к более короткому целому без знака или со знаком путем усечения старших битов. Целое без знака преобразуется к более длинному целому без знака или со знаком путем дополнения нулей слева. 

Когда целое без знака преобразуется к целому со знаком того же размера, битовое представление не изменяется. Поэтому значение, которое оно представляет, изменяется, если знаковый бит установлен (равен 1), то есть когда исходное целое без знака больше чем максимальное положительное целое со знаком, такой же длины. 

Целые значения без знака преобразуются к плавающему типу, путем преобразования целого без знака к значению типа signed long, а затем значение signed long преобразуется в плавающий тип. Преобразования из unsigned long к типу float или double производятся с потерей информации, если преобразуемое значение больше, чем максимальное положительное значение, которое может быть представлено для типа long. \killoverfullbefore \BL 

\index{Выражения и присваивания!Преобразование типов!Преобразование плавающих типов}
\mylbl{Преобразование плавающих типов}{TypeConversionFloat} \BL

Величины типа float преобразуются к типу double без изменения значения. Величины double  преобразуются к float c некоторой потерей точности. Если значение слишком велико для float, то происходит потеря значимости. 

При преобразовании величины с плавающей точкой к целым типам она сначала преобразуется к типу long (дробная часть плавающей величины при этом отбрасывается), а затем величина типа long преобразуется к требуемому целому типу. Если значение слишком велико для long, то результат преобразования не определен. 

Преобразования из float или double к типу unsigned long производится с потерей точности, если преобразуемое значение больше, чем максимально возможное положительное значение, представленное типом long. \killoverfullbefore \BL 

\index{Выражения и присваивания!Преобразование типов!Преобразование типов указателя}
\mylbl{Преобразование типов указателя}{TypeConversionPointer} \BL

Указатель на величину одного типа может быть преобразован к указателю на величину другого типа. Однако результат может быть не определен из-за отличий в требованиях к выравниванию и размерах для различных типов. \killoverfullbefore

Указатель на тип void может быть преобразован к указателю на любой тип, и указатель на любой тип может быть преобразован к указателю на тип void без ограничений. Значение указателя может быть преобразовано к целой величине. \killoverfullbefore

Метод преобразования зависит от размера указателя и размера целого типа следующим образом: 
\begin{itemize}
\item если размер указателя меньше размера целого типа или равен ему, то указатель преобразуется точно так же, как целое без знака;
\item если указатель больше, чем размер целого типа, то указатель сначала преобразуется к указателю с тем же размером, что и целый тип, и затем преобразуется к целому типу. \killoverfullbefore \BL
\end{itemize}

Целый тип может быть преобразован к адресному типу по следующим правилам: 
\begin{itemize}
\item если целый тип того же размера, что и указатель, то целая величина просто рассматривается как указатель (целое без знака);
\item если размер целого типа отличен от размера указателя, то целый тип сначала преобразуется к размеру указателя (используются способы преобразования, описанные выше), а затем полученное значение трактуется как указатель.\killoverfullbefore \BL 
\end{itemize}

\index{Выражения и присваивания!Преобразование типов!Преобразование при вызове функции}
\mylbl{Преобразование при вызове функции}{TypeConversionFunction} \BL

Преобразования, выполняемые над аргументами при вызове функции, зависят от того, был ли задан прототип функции (раннее объявление) со списком объявлений типов аргументов. \killoverfullbefore

Если имеется прототип функции, который включает объявленные типы аргументов, то осуществляется проверка типов.\killoverfullbefore

Если прототип функции отсутствует, то проводятся только обычные арифметические преобразования каждого аргумента в вызове функции: величины float преобразуются в double, char или short в int, unsigned char или unsigned short в unsigned int. \killoverfullbefore \BL

%Если задан прототип функции и он включает объявление типов аргументов, то над аргументами в вызове функции выполняются только обычные арифметические преобразования. Могут быть также выполнены неявные преобразования переменных типа указатель.\killoverfullbefore \BL

%Эти преобразования выполняются независимо для каждого аргумента. Величины типа float преобразуются к double, величины типа char и short преобразуются к int, величины типов unsigned char и unsigned short преобразуются к unsigned int. Могут быть также выполнены неявные преобразования переменных типа указатель. Задавая прототипы функций, можно переопределить эти неявные преобразования и позволить компилятору выполнить контроль типов.\killoverfullbefore \BL 

\index{Выражения и присваивания!Преобразование типов!Преобразование при приведении типов}
\mylbl{Преобразование при приведении типов}{TypeConversionCasting} \BL

Явное преобразование типов может быть осуществлено посредством операции приведения типов, которая имеет формат: (<спецификатор-типа>) операнд, где <спецификатор-типа> задает тип, к которому должен быть преобразован операнд, операнд ~-- значение, которое будет преобразовано в заданный тип. \killoverfullbefore \BL 

\begin{pExample}
\IncludeLstWithoutBorder{./listings/NullSample.pas}{~}{lst:TypeConversion}
\begin{tabular}{ l l }
int i=2; & \textcolor{exComm}{/* Объявление переменной типа int */} \\
long l=2; & \textcolor{exComm}{/* Объявление переменной типа long */} \\
double d; & \textcolor{exComm}{/* Объявление переменной типа double */} \\
float f; & \textcolor{exComm}{/* Объявление переменной типа float */} \\
d=(double)i *(double)l; & \textcolor{exComm}{/* Величины i, l, d будут явно преобразовываться */} \\
f=(float)d; & \textcolor{exComm}{/* к указанным в круглых скобках типам */} \\
\end{tabular}
\end{pExample}
% *******end section*****************
% *******end section*****************
%--------------------------------------------------------
\index{Выражения и присваивания|)}

\clearpage